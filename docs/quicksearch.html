<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: utils.js 'use strict'; var chalk = require('chalk'); /** * Print a task name in a custom format * * @since 0.5.0 * @public * * @param {string} name The name of the task */ function printTask(name) { process.stdout.write(chalk.blue(name + ' task:\\n===================================\\n')); } /** * Outputs the task status * * @since 0.5.0 * @public * * @param {string} taskName The task name * * @return {Function} The function to be fired when is loaded */ function task(taskName) { var time = process.hrtime(); process.stdout.write(chalk.green(taskName) + ': .'); var si = setInterval(function() { process.stdout.write('.'); }, 100); return function(message) { var diff = process.hrtime(time); process.stdout.write(message || '' + chalk.yellow(' (' + ((diff[0] * 1e9 + diff[1]) * 1e-9).toFixed(2) + ' secs)\\n')); clearInterval(si); }; } /** * Check if e value is between a min and a max * * @since 0.5.0 * @public * * @param {number} value * @param {number} min * @param {number} max * * @return {Boolean} */ function isInRange(value, min, max) { return !Math.floor((value - min) / (max - min)); } /** * Transforms a dasherize string into a camel case one. * * @since 0.3.2 * @public * * @param {string} value The dasherize string * * @return {string} The camel case string */ function dashToCamelCase(value) { return value .toLowerCase() .replace(/-([a-z])/g, function(match) { return match[1].toUpperCase(); }); } /** * Create a literal object of the node module options * * @since 0.1.0 * @public * * @param {Array} args The array of arguments (the module arguments start from index 2) * * @return {Object} The object containg the key/value options */ function getBashOptions(args) { var settings = {}; for (var i = 2; i &lt; args.length; i++) { var paramArray = args[i].split('='); var key = paramArray[0].replace('--', ''); var value = paramArray[1]; settings[dashToCamelCase(key)] = value || true; } return settings; } /** * Format a date into a string * * @since 0.5.0 * @public * * @param {Date} date * @return {string} */ function formatDate(date) { return ('0' + date.getDate()).slice(-2) + '/' + ('0' + (date.getMonth() + 1)).slice(-2) + '/' + date.getFullYear(); } module.exports = { printTask: printTask, task: task, getBashOptions: getBashOptions, dashToCamelCase: dashToCamelCase, isInRange: isInRange, formatDate: formatDate }; × Search results Close "},"gren.js.html":{"id":"gren.js.html","title":"Source: gren.js","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: gren.js 'use strict'; var utils = require('./utils'); var githubInfo = require('./github-info'); var Github = require('github-api'); var fs = require('fs'); var chalk = require('chalk'); var Promise = Promise || require('es6-promise').Promise; var isOnline = require('is-online'); var ObjectAssign = require('object-assign'); var defaults = { tags: false, timeWrap: 'latest', // || history changelogFilename: 'CHANGELOG.md', dataSource: 'issues', // || commits draft: false, force: false, prefix: '', includeMessages: 'commits', // || merges || all prerelease: false, dateZero: new Date(0), override: false }; /** * Edit arelease from a given tag (in the options) * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {number} releaseId The id of the release to edit * @param {Object} releaseOptions The options to build the release: * @example * { * &quot;tag_name&quot;: &quot;v1.0.0&quot;, * &quot;target_commitish&quot;: &quot;master&quot;, * &quot;name&quot;: &quot;v1.0.0&quot;, * &quot;body&quot;: &quot;Description of the release&quot;, * &quot;draft&quot;: false, * &quot;prerelease&quot;: false * } * * @return {Promise} */ function editRelease(gren, releaseId, releaseOptions) { var loaded = utils.task('Updating latest release'); return new Promise(function(resolve, reject) { gren.repo.updateRelease(releaseId, releaseOptions, function(err, release) { loaded(); if (err) { reject(chalk.red(err)); } else { console.log(chalk.green('\\n\\n' + release.name + ' has been successfully updated!')); resolve(true); } }); }); } /** * Create a release from a given tag (in the options) * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object} releaseOptions The options to build the release: * @example { * &quot;tag_name&quot;: &quot;v1.0.0&quot;, * &quot;target_commitish&quot;: &quot;master&quot;, * &quot;name&quot;: &quot;v1.0.0&quot;, * &quot;body&quot;: &quot;Description of the release&quot;, * &quot;draft&quot;: false, * &quot;prerelease&quot;: false * } * * @return {Promise} */ function createRelease(gren, releaseOptions) { var loaded = utils.task('Preparing the release'); return new Promise(function(resolve, reject) { gren.repo.createRelease(releaseOptions, function(err, release) { loaded(); if (err) { var responseText = JSON.parse(err.request.responseText); console.log(chalk.red( responseText.message + '\\n' + responseText.errors[0].code )); reject(false); } else { console.log(chalk.green('\\n\\n' + release.name + ' has been successfully created!')); resolve(true); } }); }); } /** * Creates the options to make the release * * @since 0.2.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object[]} tags The collection of tags * * @return {Promise} */ function prepareRelease(gren, block) { var releaseOptions = { tag_name: block.release, name: gren.options.prefix + block.release, body: block.body, draft: gren.options.draft, prerelease: gren.options.prerelease }; if (block.id) { return editRelease(gren, block.id, releaseOptions); } else { return createRelease(gren, releaseOptions); } } /** * Get the tags information from the given ones, and adds * the next one in case only one is given * * @since 0.5.0 * @private * * @param {Boolean|Array} selectedTags * @param {Object[]} tags * * @return {Boolean|Array} */ function getSelectedTags(optionTags, tags) { if (!optionTags) { return false; } var selectedTags = [].concat(optionTags); return tags.filter(function(tag, index) { var isSelectedTag = selectedTags.indexOf(tag.name) !== -1; if (isSelectedTag &amp;&amp; selectedTags.length === 1 &amp;&amp; tags[index + 1]) { selectedTags.push(tags[index + 1].name); } return isSelectedTag; }).slice(0, 2); } /** * Get all the tags of the repo * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} */ function getLastTags(gren, releases) { var loaded = utils.task('Getting tags'); return new Promise(function(resolve, reject) { gren.repo.listTags(function(err, tags) { loaded(); if (err) { reject(err); } else { var filteredTags = (getSelectedTags(gren.options.tags, tags) || [tags[0], tags[1]]) .map(function(tag) { var tagRelease = releases &amp;&amp; releases.filter(function(release) { return release.tag_name === tag.name; })[0] || false; var releaseId = tagRelease ? tagRelease.id : null; return { tag: tag, releaseId: releaseId }; }); if (filteredTags[0].releaseId &amp;&amp; !gren.options.override) { reject(chalk.red(filteredTags[0].tag.name + ' is a release, use --override flag to override an existing release!')); } console.log('Tags found: ' + filteredTags.map(function(tag) { return tag.tag.name; }).join(', ')); resolve(filteredTags); } }); }); } /** * Get the dates of the last two tags * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object[]} tags List of all the tags in the repo * * @return {Promise[]} The promises which returns the dates */ function getTagDates(gren, tags) { return tags.map(function(tag) { return new Promise(function(resolve, reject) { gren.repo.getCommit(tag.tag.commit.sha, function(err, commit) { if (err) { reject(err); } else { resolve({ id: tag.releaseId, name: tag.tag.name, date: commit.committer.date }); } }); }); }); } /** * Get all releases * * @since 0.5.0 * @private * * @param {Object[]} releases A list of release Objects * * @return {Array} The list of the dates */ function getReleaseDates(gren, releases) { return [].concat(releases).map(function(release) { return { id: release.id, name: release.name, tag_name: release.tag_name, date: release.created_at, body: release.body || null }; }); } /** * Get all releases * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} The promise which resolves an array of releases */ function getListReleases(gren) { var loaded = utils.task('Getting the list of releases'); return new Promise(function(resolve, reject) { gren.repo.listReleases(function(err, releases) { loaded(); if (err &amp;&amp; err.request.status !== 404) { reject(err); } else { if (err &amp;&amp; err.request.status === 404) { resolve(false); } else { process.stdout.write(releases.length + ' releases found\\n'); resolve(releases); } } }); }); } /** * Get the latest releases * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} The promise which resolves the tag name of the release */ function getLastTwoReleases(gren) { return getListReleases(gren) .then(function(releases) { return releases.slice(0, 2); }); } /** * Return a string with a - to be a bulvar list (used for a mapping) * * @since 0.1.0 * @private * * @param {string} message * * @return {string} */ function templateCommits(message) { return '- ' + message; } /** * Generate the MD template from all the labels of a specific issue * * @since 0.5.0 * @private * * @param {Object} issue * * @return {string} */ function templateLabels(issue) { return issue.labels ? issue.labels.map(function(label) { return '[**' + label.name + '**] '; }) .join('') : '[closed]'; } /** * Generate the MD template a block * * @since 0.5.0 * @private * * @param {Object} block ({name: 'v1.2.3', body: []}) * * @return {string} */ function templateBlock(block) { var date = new Date(block.date); return '## ' + block.release + ' (' + utils.formatDate(date) + ')' + '\\n\\n' + block.body; } /** * Generate the MD template for each issue * * @since 0.5.0 * @private * * @param {Object} issue * * @return {string} */ function templateIssue(issue) { return '- ' + templateLabels(issue) + issue.title + ' [#' + issue.number + '](' + issue.html_url + ')'; } /** * Generate the Changelog MD template * * @since 0.5.0 * @private * * @param {Object[]} blocks * * @return {string} */ function templateChangelog(blocks) { return '# Changelog\\n\\n' + blocks .map(templateBlock) .join('\\n\\n --- \\n\\n'); } /** * Generate the Changelog issues body template * * @since 0.5.0 * @private * * @param {Object[]} blocks * * @return {string} */ function templateIssueBody(body, rangeBody) { return body.length ? body.join('\\n') || rangeBody + '\\n' : '*No changelog for this release.*'; } /** * Return a commit messages generated body * * @since 0.1.0 * @private * * @param {string} message * * @return {string} */ function generateCommitsBody(gren, messages) { return messages .slice(0, -1) .filter(function(message) { var messageType = gren.options.includeMessages; var filterMap = { merges: function(message) { return message.match(/^merge/i); }, commits: function(message) { return !message.match(/^merge/i); }, all: function() { return true; } }; if (filterMap[messageType]) { return filterMap[messageType](message); } return filterMap.commits(message); }) .map(templateCommits) .join('\\n'); } /** * Transforms the commits to commit messages * * @since 0.1.0 * @private * * @param {Object[]} commits The array of object containing the commits * * @return {String[]} */ function commitMessages(commits) { return commits.map(function(commitObject) { return commitObject.commit.message; }); } /** * Gets all the commits between two dates * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {string} since The since date in ISO * @param {string} until The until date in ISO * * @return {Promise} The promise which resolves the [Array] commit messages */ function getCommitsBetweenTwo(gren, since, until) { process.stdout.write(chalk.green('Get commits between ' + utils.formatDate(new Date(since)) + ' and ' + utils.formatDate(new Date(until)) + '\\n')); var options = { since: since, until: until, per_page: 100 }; return new Promise(function(resolve, reject) { gren.repo.listCommits(options, function(err, commits) { if (err) { reject(err); } else { resolve(commitMessages(commits)); } }); }); } /** * Get the blocks of commits based on release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseRanges The array of date ranges * * @return {Promise[]} */ function getCommitBlocks(gren, releaseRanges) { console.log(chalk.blue('\\nCreating the body blocks from commits:')); return Promise.all( releaseRanges .map(function(range) { return getCommitsBetweenTwo(gren, range[1].date, range[0].date) .then(function(commits) { return { id: range[0].id, release: range[0].name, date: range[0].date, body: generateCommitsBody(gren, commits) + '\\n' }; }); }) ); } /** * Get all the closed issues from the current repo * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Array} releaseRanges The array of date ranges * * @return {Promise} The promise which resolves the list of the issues */ function getClosedIssues(gren, releaseRanges) { var loaded = utils.task('Getting all closed issues'); return new Promise(function(resolve, reject) { gren.issues.listIssues({ state: 'closed', since: releaseRanges[0][1].date }, function(err, issues) { loaded(); if (err) { reject(err); } else { var filteredIssues = issues.filter(function(issue) { return !issue.pull_request; }); process.stdout.write(filteredIssues.length + ' issues found\\n'); resolve(filteredIssues); } }); }); } /** * Get the blocks of issues based on release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseRanges The array of date ranges * * @return {Promise[]} */ function getIssueBlocks(gren, releaseRanges) { console.log('\\nCreating the body blocks from issues:'); return getClosedIssues(gren, releaseRanges) .then(function(issues) { return releaseRanges .map(function(range) { var body = (!range[0].body || gren.options.override) &amp;&amp; issues.filter(function(issue) { return utils.isInRange( Date.parse(issue.closed_at), Date.parse(range[1].date), Date.parse(range[0].date) ); }) .map(templateIssue); return { id: range[0].id, release: range[0].name, date: range[0].date, body: templateIssueBody(body, range[0].body) }; }); }); } /** * Sort releases by dates * * @since 0.5.0 * @private * * @param {Array} releaseDates * * @return {Array} */ function sortReleasesByDate(releaseDates) { return releaseDates.sort(function(release1, release2) { return new Date(release1.date) &lt; new Date(release2.date) ? 1 : -1; }); } /** * Create the ranges of release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseDates The release dates * * @return {Array} */ function createReleaseRanges(gren, releaseDates) { var ranges = []; var range = 2; var sortedReleaseDates = sortReleasesByDate(releaseDates); if (sortedReleaseDates.length === 1 || gren.options.timeWrap === 'history') { sortedReleaseDates.push({ id: 0, date: new Date(0) }); } for (var i = 0; i &lt; sortedReleaseDates.length - 1; i++) { ranges.push(sortedReleaseDates.slice(i, i + range)); } return ranges; } /** * Generate a CHANGELOG.md file based on Time and issues * * @since 0.5.0 * @private * * @return {Promise[]} */ function generateReleaseDatesChangelogBody(gren) { var releaseActions = { history: getListReleases, latest: getLastTwoReleases }; var dataSource = { issues: getIssueBlocks, commits: getCommitBlocks }; return releaseActions[gren.options.timeWrap](gren) .then(function(releases) { if (releases.length === 0) { throw chalk.red('There are no releases! Run gren to generate release notes'); } var releaseRanges = createReleaseRanges(gren, getReleaseDates(gren, releases)); return dataSource[gren.options.dataSource](gren, releaseRanges); }) .then(function(blocks) { return templateChangelog(blocks); }); } /** * Create the CHANGELOG.md file * * @since 0.5.0 * @private * * @param {string} body * * @return {boolean} */ function createChangelog(gren, body) { function createFile(fileBody) { fs.writeFile(gren.options.changelogFilename, fileBody, function(err) { if (err) { throw err; } process.stdout.write('\\n' + chalk.green('The changelog file has been saved!\\n')); return true; }); } try { fs.readFile(gren.options.changelogFilename, 'utf-8', function(err, data) { if (err) { console.error(chalk.red(err)); return; } var newReleaseName = body.match(/(##\\s[\\w\\s.]+)/)[0]; if (data.match(newReleaseName)) { if (gren.options.force) { createFile(body + '\\n\\n --- \\n\\n' + data.replace(/^(#\\s?\\w*\\n\\n)/g, '')); return true; } else if (gren.options.override) { createFile(body); return true; } console.error(chalk.red('\\nThis release is already in the changelog\\n')); return false; } createFile(body + '\\n --- \\n\\n' + data.replace(/^(#\\s?\\w*\\n\\n)/g, '')); }); } catch (e) { createFile(body); } } /** * Generate the GithubReleaseNotes getting the options from the git config * * @since 0.5.0 * @private * * @return {Promise[]} */ function generateOptions(options) { return Promise.all([ options.user ? Promise.resolve(options.user) : githubInfo.user(), options.repo ? Promise.resolve(options.repo) : githubInfo.repo(), options.token ? Promise.resolve(options.token) : githubInfo.token() ]); } /** * Check if there is connectivity * * @since 0.5.0 * @private * * @return {Promise} */ function hasNetwork() { return new Promise(function(resolve, reject) { isOnline(function(err, online) { if (err) { reject(chalk.red(err)); } resolve(online); }); }); } /** * @param {Object} [options] The options of the module * * @since 0.1.0 * @public * * @constructor */ function GithubReleaseNotes(options) { this.options = ObjectAssign({}, defaults, options || utils.getBashOptions(process.argv)); this.options.tags = this.options.tags &amp;&amp; this.options.tags.split(','); this.repo = null; this.issues = null; this.isEditingLatestRelease = false; } /** * Initialise the GithubReleaseNotes module, create the options and run * a given module method * * @since 0.5.0 * @public * * @param {function} action * * @return {Promise} The generated options */ GithubReleaseNotes.prototype.init = function() { var gren = this; return hasNetwork() .then(function(success) { if (success) { return generateOptions(gren.options); } else { throw chalk.red('You need to have network connectivity'); } }) .then(function(optionData) { gren.options = ObjectAssign(...optionData, gren.options); if (!gren.options.token) { throw chalk.red('You need to provide the token'); } var githubApi = new Github({ token: gren.options.token }); gren.repo = githubApi.getRepo(gren.options.username, gren.options.repo); gren.issues = githubApi.getIssues(gren.options.username, gren.options.repo); return true; }) .catch(function(error) { console.log(error); }); }; /** * Get All the tags, get the dates, get the commits between those dates and prepeare the release * * @since 0.1.0 * @public * * @return {Promise} */ GithubReleaseNotes.prototype.release = function() { utils.printTask('Release'); var loaded; var gren = this; var dataSource = { issues: getIssueBlocks, commits: getCommitBlocks }; return getListReleases(this) .then(function(releases) { return getLastTags(gren, releases.length ? releases : false); }) .then(function(tags) { loaded = utils.task('Getting the tag dates ranges'); return Promise.all(getTagDates(gren, tags)); }) .then(function(releaseDates) { loaded(); return dataSource[gren.options.dataSource]( gren, createReleaseRanges(gren, releaseDates) ); }) .then(function(blocks) { return prepareRelease(gren, blocks[0]); }) .then(function(success) { return success; }) .catch(function(error) { console.error(error); return gren.options.force; }); }; /** * Generate the Changelog * * @since 0.5.0 * @public * * @param {string} type The type of changelog */ GithubReleaseNotes.prototype.changelog = function() { utils.printTask('\\nChangelog'); var gren = this; return generateReleaseDatesChangelogBody(this) .then(function(changelogBody) { return createChangelog(gren, changelogBody); }) .then(function(success) { return success; }) .catch(function(error) { console.error(error); return gren.options.force; }); }; module.exports = GithubReleaseNotes; × Search results Close "},"github-info.js.html":{"id":"github-info.js.html","title":"Source: github-info.js","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: github-info.js 'use strict'; var exec = require('child_process').exec; var chalk = require('chalk'); var Promise = Promise || require('es6-promise').Promise; /** * Execute a command in the bash and run a callback * * @since 0.5.0 * @private * * @param {string} command The command to execute * @param {Function} callback The callback which returns the stdout * * @return {Promise} */ function executeCommand(command, callback) { return new Promise(function(resolve, reject) { exec(command, function(err, stdout, stderr) { if (err || stderr) { reject(err || stderr); } else { resolve(stdout.replace('\\n', '')); } }); }) .then(callback) .catch(function(error) { throw new Error(chalk.red(error) + chalk.yellow('Make sure you\\'re running the command from the repo folder, or you using the --username and --repo flags.')); }); } /** * Get user informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves user informations ({ user: username}) */ function user(callback) { return executeCommand('git config user.name', function(user) { return { user: user }; }) .then(callback); } /** * Get repo informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves repo informations ({user: user, name: name}) */ function repo(callback) { return executeCommand('git config remote.origin.url', function(repo) { var repoPath = repo .replace(/([^:]*:)|\\.[^.]+$/g, '') .split('/'); var user = repoPath[0]; var name = repoPath[1]; return { username: user, repo: name }; }) .then(callback); } /** * Get token informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves token informations ({token: token}) */ function token(callback) { return executeCommand('echo $GREN_GITHUB_TOKEN', function(token) { return { token: token }; }) .then(callback); } module.exports = { user: user, repo: repo, token: token }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Global Methods dashToCamelCase(value) Transforms a dasherize string into a camel case one. Parameters: Name Type Description value string The dasherize string Since: 0.3.2 Source: utils.js, line 68 Returns: The camel case string Type string formatDate(date) Format a date into a string Parameters: Name Type Description date Date Since: 0.5.0 Source: utils.js, line 109 Returns: Type string getBashOptions(args) Create a literal object of the node module options Parameters: Name Type Description args Array The array of arguments (the module arguments start from index 2) Since: 0.1.0 Source: utils.js, line 86 Returns: The object containg the key/value options Type Object isInRange(value, min, max) Check if e value is between a min and a max Parameters: Name Type Description value number min number max number Since: 0.5.0 Source: utils.js, line 54 Returns: Type Boolean printTask(name) Print a task name in a custom format Parameters: Name Type Description name string The name of the task Since: 0.5.0 Source: utils.js, line 13 repo(callback) Get repo informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 63 Returns: The promise that resolves repo informations ({user: user, name: name}) Type Promise task(taskName) Outputs the task status Parameters: Name Type Description taskName string The task name Since: 0.5.0 Source: utils.js, line 26 Returns: The function to be fired when is loaded Type function token(callback) Get token informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 89 Returns: The promise that resolves token informations ({token: token}) Type Promise user(callback) Get user informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 44 Returns: The promise that resolves user informations ({ user: username}) Type Promise × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Classes Classes GithubReleaseNotes × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Github Release Notes Node module that generates release notes based on commit messages or closed issues between tags. It also can create a full changelog or add the latest release notes to the existing changelog file. If you want to include it in a task, you can use grunt-github-release-notes InstallationInstall github-release-notes via npm: npm install github-release-notes -gUsagegren can be ran through the terminal, but before you can use it, you need to set up a couple of things. Github Informationsgren by default looks for your local git configuration to get the repo informations. This means you can run the command directly from the git repo folder. Otherwise, you can run it from wherever and specify a different repo as target, with: gren --username=[username] --repo=[repo name]TokenTo work, gren needs a github token (that can be easily generated following this link). You only need &quot;repo&quot; scope. Once generated, you can run the gren command with the token as variable: gren --token=your_token_hereOr you can add it to your ~/.bash_profile or ~/.zshrc) as follows: export GREN_GITHUB_TOKEN=your_token_hereAnd you're ready to use it! Just run this command in your terminal: grenThe module will look for the last tag, get all the issues closed in the time between that tag and the one before, and it will build release notes and draft the new release! OptionsFollowing the options for the module: --action=release|changelog The gren action to run. Default: release (see details below for changelog generator) --tags=0.1.0|0.2.0,0.1.0 A specific tag or the range of tags to build the release notes from. --time-wrap=latest|history The release notes you want to include in the changelog. Default: latest Only applicable to the changelog action --changelog-filename=CHANGELOG.md The name of the changelog file. Default: CHANGELOG.md --data-source=issues|commits The informations you want to use to build release notes. Default: issues --draft=true|false To set the release as a draft. Default: false --prerelease=true|false To set the release as a prerelease. Default: false --prefix=v Add a prefix to the tag version e.g. v1.0.1. Default: null --include-messages=merges|commits|all used to filter the messages added to the release notes. Default: commits --override=true|false Override the release notes if existing. Default: false ExamplesThe ways to use gren are various. SimpleThe simple way, just looks for the last tag, gets all the issues closed between that tag and the one before and creates the new release with the generated body. grenCommit messagesAdding the flag --data-source=commits will change the source of the release notes to be the commit messages. gren --data-source=commitsRelease specific tagsThe flag --tags accepts one or two tags.If you only give one tag, it will get the issues (or commit messages) between that tag and the one before.If you give two tags it will generate the release notes with the issues (or commit messages) between those two tag dates. gren --tags=2.0.0,1.0.0Override an existing releaseIf you trying to create an existing release, gren will throw an error &quot;0.3.0 is a release, use --override flag to override an existing release!If you want then to override, simple use: gren --override --tags=0.3.0Changelog Generatorgren can also update generate the changelog. The following command, will generate the release notes for the latest release, and add it to an existing file or create it in the same directory where you run the command. gren --action=changelogThe generated release notes will be added at the top of the file, and will look like this: Changelogv0.4.3 (02/03/2016)[bug] This is a issue name #123 Generate a full changelogIf tou want to generate the whole changelog, you need to use the --time-wrap=history. This will generate a changelog based on issues (or on commit messages if the --data-source=commits is present). If you want to override the existing changelog, use --override. The usage would then be: gren --time-wrap=history --overrideTo see a full example of the changelog here CHANGELOG.md × Search results Close "},"GithubReleaseNotes.html":{"id":"GithubReleaseNotes.html","title":"Class: GithubReleaseNotes","body":" DocStrap Classes GithubReleaseNotes Global dashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Class: GithubReleaseNotes GithubReleaseNotes new GithubReleaseNotes( [options]) Parameters: Name Type Argument Description options Object &lt;optional&gt; The options of the module Since: 0.1.0 Source: gren.js, line 770 Methods changelog(type) Generate the Changelog Parameters: Name Type Description type string The type of changelog Since: 0.5.0 Source: gren.js, line 877 init(action) Initialise the GithubReleaseNotes module, create the options and runa given module method Parameters: Name Type Description action function Since: 0.5.0 Source: gren.js, line 789 Returns: The generated options Type Promise release() Get All the tags, get the dates, get the commits between those dates and prepeare the release Since: 0.1.0 Source: gren.js, line 829 Returns: Type Promise × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
